// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/VadimGossip/consoleChat-chat-server/internal/model"
	"github.com/gojuno/minimock/v3"
)

// ChatRepositoryMock implements repository.ChatRepository
type ChatRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateChat          func(ctx context.Context, name string) (i1 int64, err error)
	inspectFuncCreateChat   func(ctx context.Context, name string)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatRepositoryMockCreateChat

	funcCreateChatUser          func(ctx context.Context, chatID int64, user model.User) (err error)
	inspectFuncCreateChatUser   func(ctx context.Context, chatID int64, user model.User)
	afterCreateChatUserCounter  uint64
	beforeCreateChatUserCounter uint64
	CreateChatUserMock          mChatRepositoryMockCreateChatUser

	funcDelete          func(ctx context.Context, chatID int64) (err error)
	inspectFuncDelete   func(ctx context.Context, chatID int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mChatRepositoryMockDelete

	funcSendMessage          func(ctx context.Context, msg *model.Message) (err error)
	inspectFuncSendMessage   func(ctx context.Context, msg *model.Message)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatRepositoryMockSendMessage
}

// NewChatRepositoryMock returns a mock for repository.ChatRepository
func NewChatRepositoryMock(t minimock.Tester) *ChatRepositoryMock {
	m := &ChatRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateChatMock = mChatRepositoryMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatRepositoryMockCreateChatParams{}

	m.CreateChatUserMock = mChatRepositoryMockCreateChatUser{mock: m}
	m.CreateChatUserMock.callArgs = []*ChatRepositoryMockCreateChatUserParams{}

	m.DeleteMock = mChatRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ChatRepositoryMockDeleteParams{}

	m.SendMessageMock = mChatRepositoryMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatRepositoryMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatRepositoryMockCreateChat struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockCreateChatExpectation
	expectations       []*ChatRepositoryMockCreateChatExpectation

	callArgs []*ChatRepositoryMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockCreateChatExpectation specifies expectation struct of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockCreateChatParams
	paramPtrs *ChatRepositoryMockCreateChatParamPtrs
	results   *ChatRepositoryMockCreateChatResults
	Counter   uint64
}

// ChatRepositoryMockCreateChatParams contains parameters of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatParams struct {
	ctx  context.Context
	name string
}

// ChatRepositoryMockCreateChatParamPtrs contains pointers to parameters of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatParamPtrs struct {
	ctx  *context.Context
	name *string
}

// ChatRepositoryMockCreateChatResults contains results of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatRepositoryMockCreateChat) Optional() *mChatRepositoryMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Expect(ctx context.Context, name string) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &ChatRepositoryMockCreateChatParams{ctx, name}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateChat
}

// ExpectNameParam2 sets up expected param name for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) ExpectNameParam2(name string) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.name = &name

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Inspect(f func(ctx context.Context, name string)) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Return(i1 int64, err error) *ChatRepositoryMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatRepositoryMockCreateChatResults{i1, err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatRepository.CreateChat method
func (mmCreateChat *mChatRepositoryMockCreateChat) Set(f func(ctx context.Context, name string) (i1 int64, err error)) *ChatRepositoryMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the ChatRepository.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatRepositoryMockCreateChat) When(ctx context.Context, name string) *ChatRepositoryMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &ChatRepositoryMockCreateChatParams{ctx, name},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockCreateChatExpectation) Then(i1 int64, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockCreateChatResults{i1, err}
	return e.mock
}

// Times sets number of times ChatRepository.CreateChat should be invoked
func (mmCreateChat *mChatRepositoryMockCreateChat) Times(n uint64) *mChatRepositoryMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of ChatRepositoryMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	return mmCreateChat
}

func (mmCreateChat *mChatRepositoryMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements repository.ChatRepository
func (mmCreateChat *ChatRepositoryMock) CreateChat(ctx context.Context, name string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, name)
	}

	mm_params := ChatRepositoryMockCreateChatParams{ctx, name}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockCreateChatParams{ctx, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatRepositoryMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, name)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatRepositoryMock.CreateChat. %v %v", ctx, name)
	return
}

// CreateChatAfterCounter returns a count of finished ChatRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatRepositoryMockCreateChat) Calls() []*ChatRepositoryMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat with params: %#v", *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.CreateChat")
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.CreateChat but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), afterCreateChatCounter)
	}
}

type mChatRepositoryMockCreateChatUser struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockCreateChatUserExpectation
	expectations       []*ChatRepositoryMockCreateChatUserExpectation

	callArgs []*ChatRepositoryMockCreateChatUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockCreateChatUserExpectation specifies expectation struct of the ChatRepository.CreateChatUser
type ChatRepositoryMockCreateChatUserExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockCreateChatUserParams
	paramPtrs *ChatRepositoryMockCreateChatUserParamPtrs
	results   *ChatRepositoryMockCreateChatUserResults
	Counter   uint64
}

// ChatRepositoryMockCreateChatUserParams contains parameters of the ChatRepository.CreateChatUser
type ChatRepositoryMockCreateChatUserParams struct {
	ctx    context.Context
	chatID int64
	user   model.User
}

// ChatRepositoryMockCreateChatUserParamPtrs contains pointers to parameters of the ChatRepository.CreateChatUser
type ChatRepositoryMockCreateChatUserParamPtrs struct {
	ctx    *context.Context
	chatID *int64
	user   *model.User
}

// ChatRepositoryMockCreateChatUserResults contains results of the ChatRepository.CreateChatUser
type ChatRepositoryMockCreateChatUserResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) Optional() *mChatRepositoryMockCreateChatUser {
	mmCreateChatUser.optional = true
	return mmCreateChatUser
}

// Expect sets up expected params for ChatRepository.CreateChatUser
func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) Expect(ctx context.Context, chatID int64, user model.User) *mChatRepositoryMockCreateChatUser {
	if mmCreateChatUser.mock.funcCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("ChatRepositoryMock.CreateChatUser mock is already set by Set")
	}

	if mmCreateChatUser.defaultExpectation == nil {
		mmCreateChatUser.defaultExpectation = &ChatRepositoryMockCreateChatUserExpectation{}
	}

	if mmCreateChatUser.defaultExpectation.paramPtrs != nil {
		mmCreateChatUser.mock.t.Fatalf("ChatRepositoryMock.CreateChatUser mock is already set by ExpectParams functions")
	}

	mmCreateChatUser.defaultExpectation.params = &ChatRepositoryMockCreateChatUserParams{ctx, chatID, user}
	for _, e := range mmCreateChatUser.expectations {
		if minimock.Equal(e.params, mmCreateChatUser.defaultExpectation.params) {
			mmCreateChatUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChatUser.defaultExpectation.params)
		}
	}

	return mmCreateChatUser
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.CreateChatUser
func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockCreateChatUser {
	if mmCreateChatUser.mock.funcCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("ChatRepositoryMock.CreateChatUser mock is already set by Set")
	}

	if mmCreateChatUser.defaultExpectation == nil {
		mmCreateChatUser.defaultExpectation = &ChatRepositoryMockCreateChatUserExpectation{}
	}

	if mmCreateChatUser.defaultExpectation.params != nil {
		mmCreateChatUser.mock.t.Fatalf("ChatRepositoryMock.CreateChatUser mock is already set by Expect")
	}

	if mmCreateChatUser.defaultExpectation.paramPtrs == nil {
		mmCreateChatUser.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateChatUserParamPtrs{}
	}
	mmCreateChatUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateChatUser
}

// ExpectChatIDParam2 sets up expected param chatID for ChatRepository.CreateChatUser
func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) ExpectChatIDParam2(chatID int64) *mChatRepositoryMockCreateChatUser {
	if mmCreateChatUser.mock.funcCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("ChatRepositoryMock.CreateChatUser mock is already set by Set")
	}

	if mmCreateChatUser.defaultExpectation == nil {
		mmCreateChatUser.defaultExpectation = &ChatRepositoryMockCreateChatUserExpectation{}
	}

	if mmCreateChatUser.defaultExpectation.params != nil {
		mmCreateChatUser.mock.t.Fatalf("ChatRepositoryMock.CreateChatUser mock is already set by Expect")
	}

	if mmCreateChatUser.defaultExpectation.paramPtrs == nil {
		mmCreateChatUser.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateChatUserParamPtrs{}
	}
	mmCreateChatUser.defaultExpectation.paramPtrs.chatID = &chatID

	return mmCreateChatUser
}

// ExpectUserParam3 sets up expected param user for ChatRepository.CreateChatUser
func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) ExpectUserParam3(user model.User) *mChatRepositoryMockCreateChatUser {
	if mmCreateChatUser.mock.funcCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("ChatRepositoryMock.CreateChatUser mock is already set by Set")
	}

	if mmCreateChatUser.defaultExpectation == nil {
		mmCreateChatUser.defaultExpectation = &ChatRepositoryMockCreateChatUserExpectation{}
	}

	if mmCreateChatUser.defaultExpectation.params != nil {
		mmCreateChatUser.mock.t.Fatalf("ChatRepositoryMock.CreateChatUser mock is already set by Expect")
	}

	if mmCreateChatUser.defaultExpectation.paramPtrs == nil {
		mmCreateChatUser.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateChatUserParamPtrs{}
	}
	mmCreateChatUser.defaultExpectation.paramPtrs.user = &user

	return mmCreateChatUser
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.CreateChatUser
func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) Inspect(f func(ctx context.Context, chatID int64, user model.User)) *mChatRepositoryMockCreateChatUser {
	if mmCreateChatUser.mock.inspectFuncCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.CreateChatUser")
	}

	mmCreateChatUser.mock.inspectFuncCreateChatUser = f

	return mmCreateChatUser
}

// Return sets up results that will be returned by ChatRepository.CreateChatUser
func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) Return(err error) *ChatRepositoryMock {
	if mmCreateChatUser.mock.funcCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("ChatRepositoryMock.CreateChatUser mock is already set by Set")
	}

	if mmCreateChatUser.defaultExpectation == nil {
		mmCreateChatUser.defaultExpectation = &ChatRepositoryMockCreateChatUserExpectation{mock: mmCreateChatUser.mock}
	}
	mmCreateChatUser.defaultExpectation.results = &ChatRepositoryMockCreateChatUserResults{err}
	return mmCreateChatUser.mock
}

// Set uses given function f to mock the ChatRepository.CreateChatUser method
func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) Set(f func(ctx context.Context, chatID int64, user model.User) (err error)) *ChatRepositoryMock {
	if mmCreateChatUser.defaultExpectation != nil {
		mmCreateChatUser.mock.t.Fatalf("Default expectation is already set for the ChatRepository.CreateChatUser method")
	}

	if len(mmCreateChatUser.expectations) > 0 {
		mmCreateChatUser.mock.t.Fatalf("Some expectations are already set for the ChatRepository.CreateChatUser method")
	}

	mmCreateChatUser.mock.funcCreateChatUser = f
	return mmCreateChatUser.mock
}

// When sets expectation for the ChatRepository.CreateChatUser which will trigger the result defined by the following
// Then helper
func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) When(ctx context.Context, chatID int64, user model.User) *ChatRepositoryMockCreateChatUserExpectation {
	if mmCreateChatUser.mock.funcCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("ChatRepositoryMock.CreateChatUser mock is already set by Set")
	}

	expectation := &ChatRepositoryMockCreateChatUserExpectation{
		mock:   mmCreateChatUser.mock,
		params: &ChatRepositoryMockCreateChatUserParams{ctx, chatID, user},
	}
	mmCreateChatUser.expectations = append(mmCreateChatUser.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.CreateChatUser return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockCreateChatUserExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockCreateChatUserResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.CreateChatUser should be invoked
func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) Times(n uint64) *mChatRepositoryMockCreateChatUser {
	if n == 0 {
		mmCreateChatUser.mock.t.Fatalf("Times of ChatRepositoryMock.CreateChatUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChatUser.expectedInvocations, n)
	return mmCreateChatUser
}

func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) invocationsDone() bool {
	if len(mmCreateChatUser.expectations) == 0 && mmCreateChatUser.defaultExpectation == nil && mmCreateChatUser.mock.funcCreateChatUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChatUser.mock.afterCreateChatUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChatUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChatUser implements repository.ChatRepository
func (mmCreateChatUser *ChatRepositoryMock) CreateChatUser(ctx context.Context, chatID int64, user model.User) (err error) {
	mm_atomic.AddUint64(&mmCreateChatUser.beforeCreateChatUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChatUser.afterCreateChatUserCounter, 1)

	if mmCreateChatUser.inspectFuncCreateChatUser != nil {
		mmCreateChatUser.inspectFuncCreateChatUser(ctx, chatID, user)
	}

	mm_params := ChatRepositoryMockCreateChatUserParams{ctx, chatID, user}

	// Record call args
	mmCreateChatUser.CreateChatUserMock.mutex.Lock()
	mmCreateChatUser.CreateChatUserMock.callArgs = append(mmCreateChatUser.CreateChatUserMock.callArgs, &mm_params)
	mmCreateChatUser.CreateChatUserMock.mutex.Unlock()

	for _, e := range mmCreateChatUser.CreateChatUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateChatUser.CreateChatUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChatUser.CreateChatUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChatUser.CreateChatUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChatUser.CreateChatUserMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockCreateChatUserParams{ctx, chatID, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChatUser.t.Errorf("ChatRepositoryMock.CreateChatUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmCreateChatUser.t.Errorf("ChatRepositoryMock.CreateChatUser got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateChatUser.t.Errorf("ChatRepositoryMock.CreateChatUser got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChatUser.t.Errorf("ChatRepositoryMock.CreateChatUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChatUser.CreateChatUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChatUser.t.Fatal("No results are set for the ChatRepositoryMock.CreateChatUser")
		}
		return (*mm_results).err
	}
	if mmCreateChatUser.funcCreateChatUser != nil {
		return mmCreateChatUser.funcCreateChatUser(ctx, chatID, user)
	}
	mmCreateChatUser.t.Fatalf("Unexpected call to ChatRepositoryMock.CreateChatUser. %v %v %v", ctx, chatID, user)
	return
}

// CreateChatUserAfterCounter returns a count of finished ChatRepositoryMock.CreateChatUser invocations
func (mmCreateChatUser *ChatRepositoryMock) CreateChatUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChatUser.afterCreateChatUserCounter)
}

// CreateChatUserBeforeCounter returns a count of ChatRepositoryMock.CreateChatUser invocations
func (mmCreateChatUser *ChatRepositoryMock) CreateChatUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChatUser.beforeCreateChatUserCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.CreateChatUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChatUser *mChatRepositoryMockCreateChatUser) Calls() []*ChatRepositoryMockCreateChatUserParams {
	mmCreateChatUser.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockCreateChatUserParams, len(mmCreateChatUser.callArgs))
	copy(argCopy, mmCreateChatUser.callArgs)

	mmCreateChatUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatUserDone returns true if the count of the CreateChatUser invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockCreateChatUserDone() bool {
	if m.CreateChatUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatUserMock.invocationsDone()
}

// MinimockCreateChatUserInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockCreateChatUserInspect() {
	for _, e := range m.CreateChatUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChatUser with params: %#v", *e.params)
		}
	}

	afterCreateChatUserCounter := mm_atomic.LoadUint64(&m.afterCreateChatUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatUserMock.defaultExpectation != nil && afterCreateChatUserCounter < 1 {
		if m.CreateChatUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.CreateChatUser")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChatUser with params: %#v", *m.CreateChatUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChatUser != nil && afterCreateChatUserCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.CreateChatUser")
	}

	if !m.CreateChatUserMock.invocationsDone() && afterCreateChatUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.CreateChatUser but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatUserMock.expectedInvocations), afterCreateChatUserCounter)
	}
}

type mChatRepositoryMockDelete struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockDeleteExpectation
	expectations       []*ChatRepositoryMockDeleteExpectation

	callArgs []*ChatRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockDeleteExpectation specifies expectation struct of the ChatRepository.Delete
type ChatRepositoryMockDeleteExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockDeleteParams
	paramPtrs *ChatRepositoryMockDeleteParamPtrs
	results   *ChatRepositoryMockDeleteResults
	Counter   uint64
}

// ChatRepositoryMockDeleteParams contains parameters of the ChatRepository.Delete
type ChatRepositoryMockDeleteParams struct {
	ctx    context.Context
	chatID int64
}

// ChatRepositoryMockDeleteParamPtrs contains pointers to parameters of the ChatRepository.Delete
type ChatRepositoryMockDeleteParamPtrs struct {
	ctx    *context.Context
	chatID *int64
}

// ChatRepositoryMockDeleteResults contains results of the ChatRepository.Delete
type ChatRepositoryMockDeleteResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mChatRepositoryMockDelete) Optional() *mChatRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for ChatRepository.Delete
func (mmDelete *mChatRepositoryMockDelete) Expect(ctx context.Context, chatID int64) *mChatRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &ChatRepositoryMockDeleteParams{ctx, chatID}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.Delete
func (mmDelete *mChatRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ChatRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelete
}

// ExpectChatIDParam2 sets up expected param chatID for ChatRepository.Delete
func (mmDelete *mChatRepositoryMockDelete) ExpectChatIDParam2(chatID int64) *mChatRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ChatRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.chatID = &chatID

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.Delete
func (mmDelete *mChatRepositoryMockDelete) Inspect(f func(ctx context.Context, chatID int64)) *mChatRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by ChatRepository.Delete
func (mmDelete *mChatRepositoryMockDelete) Return(err error) *ChatRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ChatRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the ChatRepository.Delete method
func (mmDelete *mChatRepositoryMockDelete) Set(f func(ctx context.Context, chatID int64) (err error)) *ChatRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the ChatRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the ChatRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the ChatRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mChatRepositoryMockDelete) When(ctx context.Context, chatID int64) *ChatRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &ChatRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ChatRepositoryMockDeleteParams{ctx, chatID},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.Delete return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockDeleteExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.Delete should be invoked
func (mmDelete *mChatRepositoryMockDelete) Times(n uint64) *mChatRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of ChatRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	return mmDelete
}

func (mmDelete *mChatRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements repository.ChatRepository
func (mmDelete *ChatRepositoryMock) Delete(ctx context.Context, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, chatID)
	}

	mm_params := ChatRepositoryMockDeleteParams{ctx, chatID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockDeleteParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("ChatRepositoryMock.Delete got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmDelete.t.Errorf("ChatRepositoryMock.Delete got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ChatRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ChatRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, chatID)
	}
	mmDelete.t.Fatalf("Unexpected call to ChatRepositoryMock.Delete. %v %v", ctx, chatID)
	return
}

// DeleteAfterCounter returns a count of finished ChatRepositoryMock.Delete invocations
func (mmDelete *ChatRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ChatRepositoryMock.Delete invocations
func (mmDelete *ChatRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mChatRepositoryMockDelete) Calls() []*ChatRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.Delete")
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.Delete but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), afterDeleteCounter)
	}
}

type mChatRepositoryMockSendMessage struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockSendMessageExpectation
	expectations       []*ChatRepositoryMockSendMessageExpectation

	callArgs []*ChatRepositoryMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockSendMessageExpectation specifies expectation struct of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockSendMessageParams
	paramPtrs *ChatRepositoryMockSendMessageParamPtrs
	results   *ChatRepositoryMockSendMessageResults
	Counter   uint64
}

// ChatRepositoryMockSendMessageParams contains parameters of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageParams struct {
	ctx context.Context
	msg *model.Message
}

// ChatRepositoryMockSendMessageParamPtrs contains pointers to parameters of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageParamPtrs struct {
	ctx *context.Context
	msg **model.Message
}

// ChatRepositoryMockSendMessageResults contains results of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mChatRepositoryMockSendMessage) Optional() *mChatRepositoryMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) Expect(ctx context.Context, msg *model.Message) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &ChatRepositoryMockSendMessageParams{ctx, msg}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatRepositoryMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSendMessage
}

// ExpectMsgParam2 sets up expected param msg for ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) ExpectMsgParam2(msg *model.Message) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatRepositoryMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.msg = &msg

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) Inspect(f func(ctx context.Context, msg *model.Message)) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) Return(err error) *ChatRepositoryMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatRepositoryMockSendMessageResults{err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatRepository.SendMessage method
func (mmSendMessage *mChatRepositoryMockSendMessage) Set(f func(ctx context.Context, msg *model.Message) (err error)) *ChatRepositoryMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatRepository.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatRepository.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the ChatRepository.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatRepositoryMockSendMessage) When(ctx context.Context, msg *model.Message) *ChatRepositoryMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatRepositoryMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatRepositoryMockSendMessageParams{ctx, msg},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockSendMessageExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockSendMessageResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.SendMessage should be invoked
func (mmSendMessage *mChatRepositoryMockSendMessage) Times(n uint64) *mChatRepositoryMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of ChatRepositoryMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	return mmSendMessage
}

func (mmSendMessage *mChatRepositoryMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements repository.ChatRepository
func (mmSendMessage *ChatRepositoryMock) SendMessage(ctx context.Context, msg *model.Message) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, msg)
	}

	mm_params := ChatRepositoryMockSendMessageParams{ctx, msg}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockSendMessageParams{ctx, msg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessage.t.Errorf("ChatRepositoryMock.SendMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmSendMessage.t.Errorf("ChatRepositoryMock.SendMessage got unexpected parameter msg, want: %#v, got: %#v%s\n", *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatRepositoryMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatRepositoryMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, msg)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatRepositoryMock.SendMessage. %v %v", ctx, msg)
	return
}

// SendMessageAfterCounter returns a count of finished ChatRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatRepositoryMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatRepositoryMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatRepositoryMockSendMessage) Calls() []*ChatRepositoryMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.SendMessage with params: %#v", *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.SendMessage")
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.SendMessage but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), afterSendMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateChatInspect()

			m.MinimockCreateChatUserInspect()

			m.MinimockDeleteInspect()

			m.MinimockSendMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateChatDone() &&
		m.MinimockCreateChatUserDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockSendMessageDone()
}
